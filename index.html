<!doctype html>
<html lang="uk">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Pac‑Emergence — Простий Pac‑Man на JS</title>
    <style>
        /* --- Basic layout --- */
        :root{
            --cell:24px;
            --cols:21;
            --rows:21;
            --canvas-width:calc(var(--cols) * var(--cell));
            --canvas-height:calc(var(--rows) * var(--cell));
            --bg:#000;
            --wall:#0a5;
            --pac:#ff0;
            --ghost1:#e74c3c;
            --ghost2:#3498db;
            --ghost3:#f1c40f;
            --ghost4:#9b59b6;
        }
        html,body{height:100%;margin:0;font-family:Inter, Roboto, Arial, sans-serif;background:#111;color:#eee}
        .wrap{display:flex;gap:20px;padding:18px}
        .left{width:calc(var(--canvas-width) + 20px);}
        canvas{background:var(--bg);display:block;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
        .panel{width:360px;padding:12px;background:#0f1720;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
        h1{margin:0 0 10px 0;font-size:18px}
        label,button,select{display:block;margin:8px 0}
        .info{font-size:14px;line-height:1.4}
        .row{display:flex;gap:8px;align-items:center}
        button{padding:8px 12px;border-radius:6px;border:none;background:#1f2937;color:#fff;cursor:pointer}
        button:active{transform:translateY(1px)}
        .small{font-size:13px;color:#9aa}
        .legend{display:flex;gap:10px;margin-top:8px}
        .legend div{display:flex;gap:6px;align-items:center}
        .dot{width:14px;height:14px;border-radius:50%}
        .controls{margin-top:12px}
        select{padding:6px;border-radius:6px;background:#0b1220;color:#fff;border:1px solid #21303a}
        .footer{margin-top:10px;font-size:13px;color:#9aa}
    </style>
</head>
<body>
    <div class="wrap">
        <div class="left">
            <canvas id="game" width="" height=""></canvas>
        </div>
        <div class="panel">
            <h1>Pac‑Emergence — гра</h1>
            <div class="info">
                Грати: стрілки (↑↓←→). Мета: зібрати всі точки, уникати привидів. Зелена — стіни.
            </div>
            <div style="margin-top:10px">
                <label>Рівень:
                    <select id="levelSelect">
                        <option value="1">1 — Легкий</option>
                        <option value="2">2 — Середній</option>
                        <option value="3">3 — Важкий</option>
                    </select>
                </label>
                <label>Швидкість (глобальний множник):
                    <input id="speedRange" type="range" min="0.5" max="2" step="0.1" value="1">
                </label>
                <div class="row">
                    <button id="startBtn">Старт / Перезапуск</button>
                    <button id="pauseBtn">Пауза</button>
                </div>
            </div>
            <div style="margin-top:10px">
                <div class="legend">
                    <div><span class="dot" style="background:var(--pac)"></span> Pac‑Man</div>
                    <div><span class="dot" style="background:var(--ghost1)"></span> Привид A</div>
                    <div><span class="dot" style="background:var(--ghost2)"></span> Привид B</div>
                    <div><span class="dot" style="background:var(--ghost3)"></span> Привид C</div>
                    <div><span class="dot" style="background:var(--ghost4)"></span> Привид D</div>
                </div>
            </div>
            <div class="controls">
                <div class="small">Статус: <span id="status">Готово</span></div>
                <div class="small">Життя: <span id="lives">3</span></div>
                <div class="small">Рахунок: <span id="score">0</span></div>
                <div class="small">Рівень: <span id="levelLabel">1</span></div>
            </div>
            <div class="footer">
                Складність регулюється включенням/вимкненням підмножини правил: видимість Пакмена, обмін позиціями між привидами, прогнозування ходів інших привидів. Кожен привид використовує прості правила, але разом дають складну (emergent) поведінку.
            </div>
        </div>
    </div>

    <script>
        // Pac-Emergence: single-file game
        (function(){
            // Config
            const cols = 21, rows = 21; // must be odd so center exists
            const cell = 24;
            const canvas = document.getElementById('game');
            canvas.width = cols * cell;
            canvas.height = rows * cell;
            const ctx = canvas.getContext('2d');

            // UI
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const levelSelect = document.getElementById('levelSelect');
            const speedRange = document.getElementById('speedRange');
            const statusEl = document.getElementById('status');
            const livesEl = document.getElementById('lives');
            const scoreEl = document.getElementById('score');
            const levelLabel = document.getElementById('levelLabel');

            // Game state
            let map = []; // 0 empty/pellet, 1 wall, 2 power pellet, 3 empty (no pellet)
            let pellets = 0;
            let player = null;
            let ghosts = [];
            let running = false, paused = false;
            let lastTime = 0;
            let tick = 0;
            let lives = 3;
            let score = 0;
            let chosenLevel = 1;
            let globalSpeed = 1;

            // Utility
            function inBounds(x,y){return x>=0 && y>=0 && x<cols && y<rows}
            function idx(x,y){return y*cols+x}

            // Directions
            const DIRS = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
            const OPP = {0:1,1:0,2:3,3:2};

            // Static level maps (1 = wall, 0 = pellet, 2 = power pellet, 3 = empty)
           const STATIC_LEVELS = {
    1: [
        "111111111111111111111",
        "100000000000000000001",
        "101110111101011101101",
        "100010000000000010001",
        "101011101110111011101",
        "100000100000000100001",
        "111110101111101011111",
        "100000100000000100001",
        "101110111011101110101",
        "100000000010000000001",
        "101011111000111110101",
        "100010000000000010001",
        "101110111101011101101",
        "100000100000000100001",
        "111110101111101011111",
        "100000100000000100001",
        "101011101110111011101",
        "100000000000000000001",
        "101110111101011101101",
        "200000000000000000002",
        "111111111111111111111"
    ],
    2: [
        "111111111111111111111",
        "100000000010000000001",
        "101111101010101111101",
        "100000101000101000001",
        "101110101111101011101",
        "100010000010000010001",
        "111010111010111010111",
        "100000100000000100001",
        "101111101111101111101",
        "100000000010000000001",
        "111110111000111011111",
        "100000100000000100001",
        "101110101111101011101",
        "100010101000101010001",
        "101110101010101011101",
        "100000000010000000001",
        "101111111010111111101",
        "100000000000000000001",
        "101111111111111111101",
        "200000000000000000002",
        "111111111111111111111"
    ],
    3: [
        "111111111111111111111",
        "100000000000000000001",
        "101111111010111111101",
        "100000000010000000001",
        "101011111111111110101",
        "100010000000000010001",
        "111110111010111011111",
        "100000100000000100001",
        "101110101111101011101",
        "100000100010100000001",
        "101111101000101111101",
        "100000001000100000001",
        "111110111000111011111",
        "100000100000000100001",
        "101011101111101011101",
        "100010000010000010001",
        "101110111010111011101",
        "100000000010000000001",
        "101111111010111111101",
        "200000000000000000002",
        "111111111111111111111"
    ]
};

            // Level generation: use static maps
            function generateMap(level){
                const levelData = STATIC_LEVELS[level] || STATIC_LEVELS[1];
                const m = new Array(cols * rows).fill(0);
                let pelletCount = 0;

                // Convert string map to array
                for(let y = 0; y < rows; y++){
                    const row = levelData[y] || "1".repeat(cols);
                    for(let x = 0; x < cols; x++){
                        const char = row[x] || '1';
                        const value = parseInt(char);
                        m[idx(x, y)] = value;
                        
                        if(value === 0){
                            pelletCount++;
                        }
                    }
                }

                return {map: m, pellets: pelletCount};
            }

            // Entities
            function resetEntities(){
                // player at left-top open spot
                let px=1,py=1;
                // find nearest empty
                for(let y=1;y<rows-1;y++)for(let x=1;x<cols-1;x++){
                    if(map[idx(x,y)]!==1){
                        px=x;py=y;
                        y=rows; break
                    }
                }
                player = {x:px,y:py,dir:{x:0,y:0},nextDir:null,protected:0, speed:1, radius:cell*0.45};

                // ghosts at center area
                const centerX = Math.floor(cols/2), centerY = Math.floor(rows/2);
                const colors = ['var(--ghost1)','var(--ghost2)','var(--ghost3)','var(--ghost4)'];
                ghosts = [];
                const positions = [[centerX-1,centerY],[centerX+1,centerY],[centerX,centerY-1],[centerX,centerY+1]];
                for(let i=0;i<4;i++){
                    ghosts.push({id:i,x:positions[i][0],y:positions[i][1],dirIndex:Math.floor(Math.random()*4),state:'scatter',color:colors[i],frightened:0, speed:0.9});
                }
            }

            // Ghost sensing & simple rules — these are toggled per level
            function getRulesForLevel(level){
                // base: all levels ghosts see the maze
                const rules = {
                    seeMaze:true,
                    seePacman:false,
                    seeGhosts:false,
                    predictOthers:false,
                    chaseDistance:3,
                    coordination:false
                };
                if(level===1){
                    rules.seePacman=false;
                    rules.seeGhosts=false;
                    rules.predictOthers=false;
                    rules.chaseDistance=2
                } else if(level===2){
                    rules.seePacman=true;
                    rules.seeGhosts=true;
                    rules.predictOthers=false;
                    rules.chaseDistance=5
                } else {
                    rules.seePacman=true;
                    rules.seeGhosts=true;
                    rules.predictOthers=true;
                    rules.chaseDistance=8;
                    rules.coordination=true
                }
                return rules;
            }

            // Line-of-sight: check if there's an unobstructed straight path (uses simple Bresenham)
            function hasLineOfSight(sx,sy,tx,ty){
                let x0=sx,y0=sy,x1=tx,y1=ty;
                const dx=Math.abs(x1-x0), dy=Math.abs(y1-y0);
                let sxn = x0 < x1 ? 1 : -1;
                let syn = y0 < y1 ? 1 : -1;
                let err = dx - dy;
                while(true){
                    if(map[idx(x0,y0)]===1) return false;
                    if(x0===x1 && y0===y1) break;
                    let e2 = err*2;
                    if(e2 > -dy){ err -= dy; x0 += sxn; }
                    if(e2 < dx){ err += dx; y0 += syn; }
                }
                return true;
            }

            // Ghost AI tick: each ghost uses simple rules
            function ghostDecide(ghost, rules){
                // possible moves on grid (no diagonal) that are not walls
                const posx = ghost.x, posy = ghost.y;
                const moves = [];
                for(let d=0;d<4;d++){
                    const nx=posx+DIRS[d].x, ny=posy+DIRS[d].y;
                    if(inBounds(nx,ny) && map[idx(nx,ny)]!==1){
                        moves.push({d,dpos:{x:nx,y:ny}})
                    }
                }
                if(moves.length===0) return; // trapped

                // If frightened, random
                if(ghost.frightened>0){
                    const choice = moves[Math.floor(Math.random()*moves.length)];
                    ghost.dirIndex = choice.d;
                    return
                }

                // If can see Pacman and in chaseDistance or has line of sight, chase directly
                const canSeePac = rules.seePacman && (Math.abs(player.x-posx)+Math.abs(player.y-posy) <= rules.chaseDistance) && hasLineOfSight(posx,posy,player.x,player.y);
                if(canSeePac){
                    // choose move that minimizes manhattan distance to Pacman
                    let best=null, bestScore=1e9;
                    for(const mv of moves){
                        const sc = Math.abs(mv.dpos.x-player.x)+Math.abs(mv.dpos.y-player.y);
                        if(sc<bestScore){bestScore=sc; best=mv}
                    }
                    if(best) {
                        ghost.dirIndex = best.d;
                        return
                    }
                }

                // If sees other ghosts and coordination is enabled, use simple flocking: avoid crowding and align direction
                if(rules.seeGhosts){
                    // compute center of nearby ghosts
                    let cx=0,cy=0,count=0;
                    for(const g of ghosts){
                        if(g!==ghost && Math.abs(g.x-posx)+Math.abs(g.y-posy)<=3){
                            cx+=g.x; cy+=g.y; count++
                        }
                    }
                    if(count>0){
                        cx/=count; cy/=count;
                        // prefer moves that increase distance from group center (avoid clustering) with slight alignment
                        let best=null, bestScore=-1e9;
                        for(const mv of moves){
                            const dist = -Math.abs(mv.dpos.x-cx)-Math.abs(mv.dpos.y-cy); // negative of manhattan
                            // add small bonus for aligning with average dir
                            let alignBonus = 0;
                            if(rules.predictOthers){
                                let avgDirX=0,avgDirY=0,ct=0;
                                for(const g of ghosts){
                                    if(g!==ghost){
                                        const gd = DIRS[g.dirIndex] || {x:0,y:0};
                                        avgDirX+=gd.x; avgDirY+=gd.y; ct++
                                    }
                                }
                                if(ct>0){
                                    avgDirX/=ct; avgDirY/=ct;
                                    alignBonus = (mv.dpos.x-posx)*avgDirX + (mv.dpos.y-posy)*avgDirY
                                }
                            }
                            const score = (-Math.abs(mv.dpos.x-cx)-Math.abs(mv.dpos.y-cy)) + alignBonus*0.3 - (Math.abs(mv.dpos.x-player.x)+Math.abs(mv.dpos.y-player.y))*0.05;
                            if(score>bestScore){bestScore=score; best=mv}
                        }
                        if(best){
                            ghost.dirIndex = best.d;
                            return
                        }
                    }
                }

                // default: random walk but avoid reversing direction unless forced
                // prevent immediate backtrack
                const prefer = moves.filter(mv=> OPP[mv.d] !== ghost.dirIndex);
                const pool = prefer.length?prefer:moves;
                ghost.dirIndex = pool[Math.floor(Math.random()*pool.length)].d;
            }

            // Game tick
            function update(dt){
                if(paused) return;
                tick += dt*globalSpeed;

                // player movement: move every X seconds depending on speed
                const playerSpeed = 4 * (player.speed) * globalSpeed; // cells per second
                const ghostBaseSpeed = 3.2;

                // move player when tick threshold reached
                // we'll advance discrete steps per cell with fractional accumulation
                if(!player.acc) player.acc=0;
                player.acc += dt*playerSpeed;
                while(player.acc >= 1){
                    player.acc -= 1;
                    // apply nextDir if possible
                    if(player.nextDir){
                        const nx = player.x + player.nextDir.x, ny = player.y + player.nextDir.y;
                        if(inBounds(nx,ny) && map[idx(nx,ny)]!==1){
                            player.dir = player.nextDir;
                            player.nextDir = null
                        }
                    }
                    const nx = player.x + player.dir.x, ny = player.y + player.dir.y;
                    if(inBounds(nx,ny) && map[idx(nx,ny)]!==1){
                        player.x = nx;
                        player.y = ny;
                    }

                    // collect pellet
                    const cellVal = map[idx(player.x,player.y)];
                    if(cellVal===0){
                        map[idx(player.x,player.y)]=3;
                        pellets--;
                        score+=10
                    } else if(cellVal===2){
                        map[idx(player.x,player.y)]=3;
                        pellets--;
                        score+=50;
                        ghosts.forEach(g=>g.frightened=6);
                    }
                }

                // update ghosts
                for(const g of ghosts){
                    if(!g.acc) g.acc=0;
                    g.acc += dt * (g.speed*globalSpeed);
                    // frightened decay
                    if(g.frightened>0) g.frightened = Math.max(0, g.frightened - dt);
                    while(g.acc>=1){
                        g.acc-=1;
                        // discrete step
                        const rules = getRulesForLevel(chosenLevel);
                        ghostDecide(g,rules);
                        const d = DIRS[g.dirIndex] || DIRS[0];
                        const nx=g.x + d.x, ny=g.y + d.y;
                        if(inBounds(nx,ny) && map[idx(nx,ny)]!==1){
                            g.x=nx; g.y=ny
                        } else {
                            // choose random new dir
                            const avail = [];
                            for(let di=0;di<4;di++){
                                const tx=g.x+DIRS[di].x, ty=g.y+DIRS[di].y;
                                if(inBounds(tx,ty) && map[idx(tx,ty)]!==1) avail.push(di)
                            }
                            if(avail.length) g.dirIndex = avail[Math.floor(Math.random()*avail.length)];
                        }
                    }
                }

                // collisions
                for(const g of ghosts){
                    if(g.x===player.x && g.y===player.y){
                        if(g.frightened>0){
                            // eat ghost: send to center
                            score+=200;
                            g.x=Math.floor(cols/2);
                            g.y=Math.floor(rows/2);
                            g.frightened=0;
                            g.state='scatter';
                        } else {
                            // player dies
                            lives--;
                            livesEl.innerText = lives;
                            if(lives<=0){
                                running=false;
                                statusEl.innerText='Програш — немає життів';
                            } else {
                                statusEl.innerText='Втрата життя — перезапуск позицій';
                                resetEntities();
                            }
                        }
                    }
                }

                // win check
                if(pellets<=0){
                    running=false;
                    statusEl.innerText='Перемога! Усі точки зібрані.'
                }

                // update UI
                scoreEl.innerText = score;
            }

            function render(){
                ctx.clearRect(0,0,canvas.width,canvas.height);

                // draw map
                for(let y=0;y<rows;y++){
                    for(let x=0;x<cols;x++){
                        const v = map[idx(x,y)];
                        const px = x*cell, py = y*cell;
                        if(v===1){
                            ctx.fillStyle = '#0c4';
                            ctx.fillRect(px+2,py+2,cell-4,cell-4)
                        } else if(v===0){
                            // pellet
                            ctx.fillStyle='#ffd';
                            ctx.beginPath();
                            ctx.arc(px+cell/2,py+cell/2,2,0,Math.PI*2);
                            ctx.fill();
                        } else if(v===2){
                            ctx.fillStyle='#fff';
                            ctx.beginPath();
                            ctx.arc(px+cell/2,py+cell/2,6,0,Math.PI*2);
                            ctx.fill();
                        }
                    }
                }

                // draw player
                const px = player.x*cell + cell/2, py = player.y*cell + cell/2;
                ctx.save();
                ctx.translate(px,py);
                ctx.fillStyle='var(--pac)';
                ctx.beginPath();
                ctx.arc(0,0,cell*0.45,0,Math.PI*2);
                ctx.fill();
                ctx.restore();

                // draw ghosts
                for(const g of ghosts){
                    const gx = g.x*cell + cell/2, gy = g.y*cell + cell/2;
                    ctx.save();
                    ctx.translate(gx,gy);

                    // body
                    ctx.beginPath();
                    ctx.moveTo(-cell*0.4,cell*0.15);
                    ctx.arc(0,0,cell*0.42,Math.PI,0,false);
                    ctx.lineTo(cell*0.4,cell*0.45);
                    ctx.quadraticCurveTo(0,cell*0.05,-cell*0.4,cell*0.45);
                    ctx.closePath();
                    if(g.frightened>0){
                        ctx.fillStyle='#8ecae6'
                    } else {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue(g.color.replace('var(','').replace(')',''))||g.color
                    }
                    ctx.fill();

                    // eyes
                    ctx.fillStyle='#fff';
                    ctx.beginPath();
                    ctx.arc(-6, -2, 4,0,Math.PI*2);
                    ctx.arc(6,-2,4,0,Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle='#000';
                    ctx.beginPath();
                    ctx.arc(-6 + (DIRS[g.dirIndex].x||0)*2, -2 + (DIRS[g.dirIndex].y||0)*2, 2,0,Math.PI*2);
                    ctx.arc(6 + (DIRS[g.dirIndex].x||0)*2, -2 + (DIRS[g.dirIndex].y||0)*2, 2,0,Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }

                // HUD small
                ctx.fillStyle='rgba(255,255,255,0.03)';
                ctx.fillRect(6,6,220,44);
                ctx.fillStyle='#fff';
                ctx.font='12px sans-serif';
                ctx.fillText('Score: '+score,12,22);
                ctx.fillText('Lives: '+lives,12,38);
            }

            // Game loop
            function loop(ts){
                if(!lastTime) lastTime = ts;
                const dt = (ts-lastTime)/1000;
                lastTime = ts;
                if(running && !paused){
                    update(dt);
                }
                render();
                requestAnimationFrame(loop);
            }

            // Controls
            window.addEventListener('keydown', e=>{
                if(!running) return;
                const keyDir = {ArrowUp:{x:0,y:-1},ArrowDown:{x:0,y:1},ArrowLeft:{x:-1,y:0},ArrowRight:{x:1,y:0}}[e.key];
                if(keyDir){
                    player.nextDir = keyDir;
                    e.preventDefault()
                }
                if(e.key==='p'){
                    paused=!paused;
                    pauseBtn.innerText = paused? 'Відновити':'Пауза';
                }
            });

            startBtn.addEventListener('click', ()=>{
                initGame();
                running=true;
                paused=false;
                pauseBtn.innerText='Пауза';
                statusEl.innerText='Гра в процесі';
            });

            pauseBtn.addEventListener('click', ()=>{
                paused=!paused;
                pauseBtn.innerText = paused? 'Відновити':'Пауза';
                statusEl.innerText = paused? 'Пауза':'Гра в процесі';
            });

            levelSelect.addEventListener('change', ()=>{
                chosenLevel = parseInt(levelSelect.value);
                levelLabel.innerText = chosenLevel;
            });

            speedRange.addEventListener('input', ()=>{
                globalSpeed = parseFloat(speedRange.value)
            });

            function initGame(){
                chosenLevel = parseInt(levelSelect.value);
                levelLabel.innerText = chosenLevel;
                globalSpeed = parseFloat(speedRange.value);
                const gm = generateMap(chosenLevel);
                map = gm.map.slice();
                pellets = gm.pellets;
                score=0;
                scoreEl.innerText=score;
                lives=3;
                livesEl.innerText=lives;
                pellets = gm.pellets;
                resetEntities();
                running=true;
                paused=false;
                statusEl.innerText='Готово';
            }

            // Start loop
            requestAnimationFrame(loop);

            // Initialize once
            initGame();
        })();
    </script>
</body>
</html>